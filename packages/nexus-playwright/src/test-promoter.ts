import { writeFile, mkdir, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import { NEXUS_DIRS } from '@nexus/core';
import { TraceManager } from './trace-manager.js';
import type { FlowSpec } from './flow-runner.js';

const CONSECUTIVE_PASSES_REQUIRED = 3;

export interface PromotedTest {
  flowName: string;
  promotedAt: string;
  consecutivePasses: number;
  testPath: string;
}

export class TestPromoter {
  private readonly traceManager: TraceManager;

  constructor(private readonly cwd: string = process.cwd()) {
    this.traceManager = new TraceManager(cwd);
  }

  private generatedTestsDir(): string {
    return path.join(this.cwd, NEXUS_DIRS.PLAYWRIGHT, 'generated-tests');
  }

  async checkEligibility(flowName: string): Promise<{ eligible: boolean; consecutivePasses: number }> {
    const passes = await this.traceManager.getConsecutivePasses(flowName);
    return {
      eligible: passes >= CONSECUTIVE_PASSES_REQUIRED,
      consecutivePasses: passes,
    };
  }

  async promote(flowName: string, spec: FlowSpec): Promise<PromotedTest | null> {
    const { eligible, consecutivePasses } = await this.checkEligibility(flowName);

    if (!eligible) {
      console.log(
        `[TestPromoter] ${flowName} not eligible: ${consecutivePasses}/${CONSECUTIVE_PASSES_REQUIRED} consecutive passes`,
      );
      return null;
    }

    const testPath = path.join(this.generatedTestsDir(), `${flowName}.generated.test.ts`);
    await mkdir(this.generatedTestsDir(), { recursive: true });

    const testContent = this.generateTestCode(flowName, spec);
    await writeFile(testPath, testContent, 'utf-8');

    const promoted: PromotedTest = {
      flowName,
      promotedAt: new Date().toISOString(),
      consecutivePasses,
      testPath,
    };

    // Append to promotion log
    const logPath = path.join(this.generatedTestsDir(), 'promotion-log.json');
    let log: PromotedTest[] = [];
    if (existsSync(logPath)) {
      try {
        const raw = await readFile(logPath, 'utf-8');
        log = JSON.parse(raw) as PromotedTest[];
      } catch {}
    }
    log.push(promoted);
    await writeFile(logPath, JSON.stringify(log, null, 2), 'utf-8');

    console.log(`[TestPromoter] Promoted ${flowName} to stable test: ${testPath}`);
    return promoted;
  }

  private generateTestCode(flowName: string, spec: FlowSpec): string {
    const stepLines = spec.steps
      .map((s, i) => `  // Step ${i + 1}: ${s.description}`)
      .join('\n');

    return `/**
 * Auto-generated Playwright test for flow: ${flowName}
 * Generated by nexus-playwright TestPromoter after ${CONSECUTIVE_PASSES_REQUIRED} consecutive passes.
 * DO NOT EDIT manually â€” re-run the flow to regenerate.
 *
 * Original description: ${spec.description}
 */
import { test, expect } from '@playwright/test';

test('${flowName}', async ({ page }) => {
${stepLines}
  // TODO: Add assertions from spec.acceptanceCriteria
${spec.acceptanceCriteria.map((c) => `  // Criteria: ${c}`).join('\n')}
});
`;
  }
}
